# Huge Project Build Systems

_Summary: Shake won't scale to millions of files, this post says what would be required to make it do so._

While Shake has compiled projects with hundreds of thousands of files, it's never scaled out to millions of files, and it would be unlikely to work well at that size. The most popular build systems that operate at that scale are [Buck](https://buck.build/) (from Facebook) and [Bazel](https://bazel.build/) (from Google). In this post I go through the changes that would need to be made to make Shake scale.

The first issue is covered in my [previous post](https://neilmitchell.blogspot.com/2021/09/reflecting-on-shake-build-system.html), that Shake doesn't know if you change the build rules themselves. As you scale up, it becomes much more important that if you change the rules, everything is properly tracked. As the number of people involved in a project increases, the rate at which the build system changes will also increase. Both Buck and Bazel solve this problem using a deterministic Python-based configuration language called [Starlark](https://developers.facebook.com/blog/post/2021/04/08/rust-starlark-library/). If Shake stopped being a Haskell DSL, I'd argue that it stops being Shake and becomes something different, so it's unclear what could be done there.

The next issue is that every time Shake is invoked, it checks the modification time of every file, and then walks the entire dependency graph. That works fine at 10K files, but as you move to 1M files, it takes too long. The solution is two-fold, first be informed which files have changed using notification APIs (e.g. the [Watchman tool](https://facebook.github.io/watchman/)), and then use reverse dependencies to only explore the portion of the graph that has changed. Happily, Pepe already has a patch [adding reverse dependencies to Shake](https://github.com/ndmitchell/shake/pull/802), so that isn't too infeasible.

The final issue is that Shake was designed as a single-machine build system, not for sharing results between users. When I first wrote Shake, I didn't have access to servers, and AWS was brand new. Now, over a decade later, servers are easy to obtain and large scale build systems need to share results, so that if one user builds a file, no one else needs to. Within the realm of multi-user build systems, there are two basic operations - sharing results and offloading commands.

Shake, with it's new [cloud features](https://shakebuild.com/cloud), is able to share results between users using a shared drive. It works, and big companies are using it for real, but I'd consider it fairly experimental. For execution, Shake is unable to run actions remotely, so can't make use of something like Bazel's [remote execution API](https://bazel.build/remote-execution-services.html). Since dependencies are specified at the rule level, and remote execution operates at the command level, there is a bit of a mismatch, and it's unclear what that might look like in Shake.

While Shake won't work at _huge_ scales, it is still quite an effective build system at quite large scales. But, given the limitations, I imagine it will never get to the scale of Buck/Bazel. At the same time, Buck/Bazel lack dynamic dependencies, which makes them unable to express [rules such as Haskell](https://github.com/ghc-proposals/ghc-proposals/pull/245#issuecomment-890962688) effectively.

Happily, I am involved with a new build system, the [next generation of Buck](https://developers.facebook.com/blog/post/2021/07/01/future-of-buck/). I joined Facebook two years ago, and since that time have been focused on this project. It's written in Rust, configured with Starlark (I've spent a lot of time working on an open-source [Starlark interpreter](https://github.com/facebookexperimental/starlark-rust) in Rust), and should work at huge scales. It's not yet open source, but it will be - we are targeting early next year.

I think Shake is still a build system with a lot to offer, and continue to maintain and improve it. For people who want to scale beyond the range of Shake, I'd definitely recommend using the next generation of Buck, once it is available.
